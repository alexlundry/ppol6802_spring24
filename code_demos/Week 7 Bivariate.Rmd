---
title: "PPOL 6802 Week 7 - Bivariate Visualization"
author: "Alex Lundry"
date: "`r Sys.Date()`"
output: github_document
---

## Intro and Setup

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Today we'll be learning how to create visualizations in R and ggplot2 of bivariate data. For this demonstration we will be using the [Gapminder](https://www.gapminder.org/) dataset. If you have not already done so, please run `install.packages("gapminder")` so that you have the access to the data on your computer and your R environment.

Once that is done, load the necessary libraries in R:

```{r}
library(tidyverse)
library(scales)
library(gapminder)
```

Let's take a very quick look at the data in order to understand what we have to work with:

```{r}
glimpse(gapminder)
```

Looks like each row is an observation of a specific country in a particular year, with three numeric measures: life expectancy, population and the GDP per capita. We could, of course investigate each of these individually using the univariate visualizations we covered two weeks (bar charts, pie charts, histograms, density plots, and so on).  Let's assume for now that we have sufficiently investigated each variable in isolation, and it is now time to look at interactions between them. 

## Categorical & Numeric Variables

We'll begin first with visualizing a categorical and numeric variable together.  We begin with this one because in many ways it is the simplest of our interactions.  In fact, the construction of many of these visualizations will frequently be minimally different from how we built them for univariate analysis. 

Before we begin, let's get our data ready. For this demonstration, our task is the following:

-   *Show me the populations of the 10 most populous countries in the world in 2007.*

We use our tidyverse syntax to take the gapminder data, filter it to the year 2007, sort it descending by population and then take the first 10 rows.

```{r}
d1 <- gapminder %>%
  filter(year == 2007) %>%
  arrange(desc(pop)) %>%
  slice(1:10)

d1
```

### Bar Charts

Now let's get that data into a simple bar. 

Remember your ggplot syntax! Ggplot takes as parameters a dataset, and then you must map it's aesthetic components. The dataset will be `d1` and then the aesthetics are what you are encoding the data as. So, in this one, we are encoding country as the X aesthetic (I haven't explicitly declared it here - remember that ggplot is really good at understanding what aesthetics you mean). And we want a bar chart so we need a `geom_bar` call.  

Now, you may think that's all you need, but that's a mistake, because look at what happens:

```{r}
ggplot(d1, aes(country)) +
  geom_bar()
```

That isn't right!!!  Remember that we aren't visualizing just one variable.  We are actually showing how another variable (population) varies by country.  The visualization above only mapped one of those variables.  It took that variable - `country` - and then saw that we were using `geom_bar` and applied the default stat (count) to the data.  So it simply counted, how many times do I see "United States"?  Well I see it once.  How many times do I see Bangladesh?  Once. But remember from Week 5 that's not what we need.  We already have the number we want to visualize, so the "stat" we assign to it is called "identity."  And we need to make assignments for both the X and the Y axis:

```{r}
ggplot(d1, aes(country, pop)) +
  geom_bar(stat = "identity") +
  theme(legend.position = "none")
```

Ok, that's a good start, but remember all the good stuff we learned in week 5?  Here's what I want you to do:

- reorder the bars from the most populous to the least populous
- make this a horizontal bar plot
- create a new variable called `billions` and if the country has a population of one billion or more it will be true.
- color any countries that have one billion or more in population differently than other countries.
- improve the labeling of the chart, give it a title and appropriate axis labels
- label the bars with the population
- make the label human readable

Here's what it should look like:

```{r echo=FALSE}
d1 %>% 
  mutate(billions = ifelse(pop > 1000000000, T, F)) %>%
  ggplot(aes(reorder(country, pop), pop)) +
  geom_bar(aes(fill = billions), stat = "identity") +
  geom_text(aes(label = str_c(round(pop/1000000000, 1), "B")), hjust = 1.1, color = "white") +
  scale_fill_manual(values = c("black", "red")) +
  theme(legend.position = "none") +
  labs(title = "Top 10 Most Populous Countries, 2007",
       x = "",
       y  = "2007 Population") +
  scale_y_continuous(labels = label_number(scale_cut = cut_long_scale())) +
  coord_flip()
```

### Cleveland Dot Plots

There is an alternative to these bar charts that can be useful when you have a large amount of data and you want to minimize the "data-ink" in the plot.  For this demo, let's look at the life expectancy of countries in Asia in 2007. Here it is as bars:

```{r}
gapminder %>%
  filter(continent == "Asia" & 
           year == 2007) %>% 
  ggplot(aes(lifeExp, country)) +
  geom_bar(stat = "identity")
```

Certainly this could be improved and remain as bars, but changing it to a Cleveland dot plot will give us a lighter, less dense version.  Instead of having a full filled in bar, you simply place a dot at the end.

```{r}
gapminder %>%
  filter(continent == "Asia" & 
           year == 2007) %>% 
  ggplot(aes(lifeExp, country)) +
  geom_point()
```

Lighter!  But very hard to make comparisons when it isn't sorted.  So let's get that fixed.  We can do that with a `reorder` call in the aesthetic function, telling it to reorder country by the value of lifeExp.

```{r}
gapminder %>%
  filter(continent == "Asia" & 
           year == 2007) %>% 
  ggplot(aes(lifeExp, reorder(country, lifeExp))) +
  geom_point()
```

Much better!  Now this gives us a ranking of the countries by life expectancy and we can see the stunning gap in life expectancy between Japan and Afghanistan.  

We can continue to clean this up by removing unnecessary elements, like the grey background panel and horizontal reference lines, and adding a line segment connecting each point to the y axis.  Here's what each section does:

- `geom_segment` adds a line to the plot.  We have to give it a number of aesthetic mappings to work: where it should start and end on the X axis, and where it should go on the Y.  You'll notice that y and yend are identical.  It needs both to function properly.  
- `theme` allows us to first give it a specific minimal theme, and then we add two more specific customizations in which we tell it to remove the major and minor gridlines in the panel.  

The resulting effect is something that is frequently referred to as a "lollipop" chart.

```{r}
gapminder %>%
  filter(continent == "Asia" & 
           year == 2007) %>% 
  ggplot(aes(lifeExp, reorder(country, lifeExp))) +
  geom_segment(aes(x = 40, 
               xend = lifeExp, 
               y = reorder(country, lifeExp), 
               yend = reorder(country, lifeExp)),
               color = "lightgrey") +
  geom_point(color="darkred", size = 2) +
  labs (x = "Life Expectancy (years)",
        y = "",
        title = "Life Expectancy by Country",
        subtitle = "Gapminder data for Asia - 2007") +
  theme_minimal() + 
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())
```

This is much breezier than our original bar chart!

### Conditional Box Plots

Remember how to make boxplots?  All you need to do in order to make them conditional on a categorical variable is to assign that categorical variable as the X aesthetic (assuming the numeric one is assigned as the Y).

```{r}
gapminder %>% 
  filter(year ==2007) %>% 
ggplot(aes(x = continent, y = gdpPercap)) +
   geom_boxplot()
```

Note here that we are designating an x and y aesthetic, and explicitly declaring it just for clarity here (just to remind you that we can!).

We can also do a little manipulation of this to make it slightly more readable.  We do this by using a reorder function in the x aesthetic declaration, telling it to reorder continent by gdpPercap, based on a median function.  This gives us a plot that is sorted from the continent with the lowest median GDP per capita (Africa) to the continent with the highest (Oceania).

```{r}
gapminder %>% 
  filter(year ==2007) %>% 
  ggplot(aes(x = reorder(continent, gdpPercap, FUN = median), y = gdpPercap)) +
   geom_boxplot()
```

Let's improve this some more:

- Flipping this might also help (We could also have simply reversed the X and Y declarations, but this is easier (imho)).  
- Let's color by continent.  Yes, we already have it as one of the axis mappings, but it can't hurt to have it doubly encoded here.  To do this, we add an aesthetic call within `geom_boxplot` telling it to map the fill attribute to the country value.
- But let's remove any legend that it creates - that is too much redundancy. We do this by calling `theme` and specifiying that legend position should be "none." 
- And let's add some labeling to the plot: title, subtitle, X and Y axis labels.
- Finally, I'd like to pretty up that axis labeling by calling the appropriate scales function.  To do this, we must add a call to change the Y axis scale, so we use `scale_y_continuous` and we tell it to adjust the labels, using a function from the `scales` package called `label_dollar`.  If you recall from our previous lesson, we use the `label_` functions when we are changing scale labels.  

```{r}
gapminder %>% 
  filter(year ==2007) %>% 
  ggplot(aes(x = reorder(continent, gdpPercap, FUN = median), y = gdpPercap)) +
  geom_boxplot(aes(fill = continent)) +
  labs(title = "Distribution of Country's GDP per Capita by Continent",
       subtitle = "Gapminder 2007 data",
       x = "Continent",
       y = "GDP per Capita") +
  scale_y_continuous(labels = label_dollar()) +
  coord_flip() +
  theme(legend.position = "none")
```
This looks great!

### Grouped Kernel Density Plots

As you may recall from week 5, the kernel density plot is basically just a smoothed histogram. When we want to display the distribution of a numeric variable for a number of categorical variables, showing histograms can get a bit chaotic and overwhelming.  In these instances the density plots can be more useful.  

As before with the boxplots, all we need to do is change the geom and add a new aesthetic call.  In this case, mapping `fill` to our categorical variable.  The one additional item here is a fixed designation in `geom_density` that sets the alpha - or transparency - to 0.4.  The alpha can range from 0 (completely transparent) to 1 (completely opaque).  We want it to be somewhat transparent because we are overlapping them all on the same axis.  This allows for direct comparison.  

```{r}
ggplot(gapminder, aes(x = gdpPercap, fill = continent)) +
   geom_density(alpha = 0.4)
```
The graph makes clear that, in general, there are a large number of countries with low GDP on the African continent.  Of course, we can clean this up in a number of ways, labels, coloring, legend, scale formatting, but you should get the picture by now.  Instead, let's move on to some other visualizations.

### Joyplots / Ridgelines

A ridgeline plot (also called a joyplot) is basically the same as a kernel density plot, but spreads them out instead of having them overlap.  This is a hint of a powerful visualization technique we'll learn shortly called "faceting."  Ridgeline plots provide a separate plot for each categorical value, but makes them more compact, allowing for some overlap.  

You create these with the `ggridges` package with `geom_density_ridges` and `theme_ridges` handling most of your use cases. Notice that since it is highly likely that the distributions will overlap, you'll want to set the alpha in `geom_density_ridges` to some value less than 1.  

```{r}
# install.packages("ggridges")
library(ggridges)

ggplot(gapminder, aes(x = gdpPercap, y = continent, fill = continent)) +
  geom_density_ridges(alpha = 0.4) +
  theme_ridges() +
  theme(legend.position = "none") # legend is redundant since we already have continent on Y
```

## Two Categorical Variables

Let's shift now to visualizing two categorical variables.  In these instances we are going to be relying on variations of the yeoman bar chart.  (And note here that technically we are actually visualizing how a numeric variable varies based on two categorical variables.)

### Stacked Bar Chart

In making bar charts of two categorical variables, we will be relying on ggplot's notion of "position."  

For these visualizations, we'll be looking at the top 5 countries by population in each continent in 2007, so let's get our data ready:

```{r}
g1 <- gapminder %>% 
   filter(year == 2007) %>% 
   group_by(continent) %>% 
   arrange(desc(pop)) %>% 
   slice(1:5) 

g1
```

First, let's see what happens if we call `geom_bar` here:  

```{r}
g1 %>% 
  ggplot(aes(continent, pop)) +
  geom_bar(stat = "identity") 
```

You see the tiny lines?  We only gave it continent and population as aesthetic mappings, so `geom_bar` is taking the rows that represent each individual country and automatically stacking those bars on top of one another.  Those are each continent's bars dividing into their respective countries.  This will be easier to see if we map fill to country:    

```{r}
g1 %>% 
  ggplot(aes(continent, pop)) +
  geom_bar(stat = "identity", aes(fill = country)) +
  theme(legend.position = "none")
```

This default behavior, when it has multiple rows to display, is `position = "stack"`.  There may be some very legitimate use cases for this type of bar chart.  For example we may want to see total population by continent, while having some sense of how many countries make up each continent.  

### Grouped Bar Chart

But this may not be exactly the right way to visualize this data, especially if we want some comparison of how individual countries within a continent compare to one another.  In this case, we can use `position = "dodge"` to turn this into a grouped bar chart.  Again, not a great chart, but this should serve for position demonstration purposes.

```{r}
g1 %>% 
   ggplot(aes(continent, pop)) +
   geom_bar(stat = "identity", aes(fill = country), position = "dodge") +
   theme(legend.position = "none")
```

### 100% Stacked Bar Chart

Finally, perhaps we are less interested in absolute numbers and instead interested in how the countries proportionally contribute to each continent.  So here we use `position = "fill"` to turn this intoa 100% stacked bar chart.  It's not a great chart, for it can be massively improved, but hopefully you get the point.

```{r}
g1 %>% 
   ggplot(aes(continent, pop)) +
   geom_bar(stat = "identity", aes(fill = country), position = "fill") +
   theme(legend.position = "none")
```

## Two Numeric Variables

When we are looking to visualize the relationship between two numeric variables you'll end up using a scatterplot, one of our most information dense visualizations.

### Scatterplot

We've actually already created a few scatterplots during our introductory lesson on ggplot!  Let's bring those back up and briefly review how to make them...

We'll look at the the relationship between GDP and life expectancy.  We declare these as our aesthetics and then the geom mapping we use is `geom_point`.  

```{r}
ggplot(gapminder, aes(gdpPercap, lifeExp)) +
   geom_point()
```

This is pretty interesting! It appears as though higher GDP is associated with higher life expectancy, but only to a point. Let's put a trend line through it to see what the model tells us.  

We can do this with a simple addition of a smooth geom - remember this is an instance of adding another stat to the visualization.  `geom_smooth()` is a statistical transformation that fits the data to a loess smoother, and then returns predictions from evenly spaced points within the range of the data.

```{r}
ggplot(gapminder, aes(gdpPercap, lifeExp)) +
   geom_point() +
   geom_smooth()
```

This sort of shape - where there is an obvious and single curve to the data - makes me think that log-transforming the data might make sense. This can be done by adding a scale_x statement; in this case `scale_x_log10`, which transforms the X axis into log scale. 

```{r}
ggplot(gapminder, aes(gdpPercap, lifeExp)) +
   geom_point() +
   scale_x_log10() +
   geom_smooth()
```

This gives us a nice linear relationship.  As always, there is a lot of cleanup that can be done to make this look nice, but this will do for the purposes of this demonstration.

## Many Variables

Now things are going to get really interesting!  Let's see what options we have available to us for multiple variables.  

### Scatterplot Matrix

First, let's consider a very useful option for your visual EDA.  The `pairs` function comes as part of R's base graphics option:

```{r}
pairs(gapminder_unfiltered)
```

Each text box represents a variable, each of the graphics in the row of that text box has that variable as the X axis, while each of the graphics in the column of that text box has that variable as the Y-axis.

Of course, it's still pretty hard to understand - the boxes are small and the `country` and `continent` graphs are odd because they're categorical data.  Let’s get rid of them using a smart select function - the `select_if()` function and the declaration `is.numeric` - it only selects the numeric variables.  

```{r}
gapminder_unfiltered %>% 
   select_if(is.numeric) %>% 
   pairs
```

This is easier to read, and I hope you can see how this can be an extremely useful tool for that initial exploratory phase of your research.  It's unlikely you'd ever actually present this visualization to anyone outside of a specialized analytics team.  

### Adding Other Aesthetics

Moving on, when we want to investigate the intersection of many variables, we should remember that we can easily add additional aesthetics to many of the plots we've already created.  

You can make aesthetic mappings to:

- color
- shape
- size
- alpha

In particular, color can be an extremely useful addition to our plots to help layer in an additional variable.  For example, we can add color mapped to continent to our previous scatterplot, giving us some more insight into how the relationship between GDP per capita and life expectancy vary by continent:

```{r}
ggplot(gapminder, aes(gdpPercap, lifeExp, color = continent)) +
   geom_point() +
   scale_x_log10() +
   geom_smooth()
```

Remember that because we put fill in the original ggplot call it is inherited by the `geom_smooth` call!  If we had not put it there, then we would have only one smoothed line. 

While you could also vary shape, size, and alpha, these are less easily discernible by viewers, so you should use them sparingly and carefully!

### Faceting

Now we arrive at an extremely powerful visual analytical tool when working with many variables: faceting.  We saw a hint of it's power when we looked ar ridgeline plots (joy plots) earlier.  

Faceting breaks a plot into subsets and display small multiples conditional on another variable.

Let's take our scatterplot of GDP per capita by life expectancy and think about how other variables come into play here. We will keep continent mapped to color, but let's also assign it to a facet.  Let's take a detailed look at the call below:

1. `data = gapminder`: dataframe
2. `aes(x = gdpPercap, y = lifeExp)`: plot variables
3. `geom_point()`: what to plot, with a aes(color = continent) attribute
4. `geom_smooth()`: a statistical transformation fits the data to a loess smoother, and then returns predictions from evenly spaced points within the range of the data.
5. `scale_x_log10()`: transforms the X axis into log scale. 
6. `facet_wrap`: breaks the plot into subsets and display small multiples conditional on the continent variable.

* note that each plot separately uses all of the calls , so there are separate geom_smooth lines for each subsetted plot

```{r}
ggplot(gapminder, 
   aes(gdpPercap, lifeExp)) +
   geom_point(aes(color = continent)) +
   geom_smooth() +
   scale_x_log10() +
   facet_wrap(~ continent)
```

One thing you can do to make the facets (potentially) more interesting is to let the x and/or y axes vary within each plot.  You do that by passing it a `scales` argument of one of the following:

* scales = "fixed": x and y scales are fixed across all panels
* scales = "free_x": the x scale is free, and the y scale is fixed
* scales = "free_y": the y scale is free, and the x scale is fixed
* scales = "free": x and y scales vary across panels.

Let's see how it looks with scales = free:

```{r}
ggplot(gapminder, 
   aes(gdpPercap, lifeExp)) +
   geom_point(aes(color = continent)) +
   geom_smooth() +
   scale_x_log10() +
   facet_wrap(~ continent, scales = "free")
```

You can also use `facet_grid` with two discrete variables to add yet another layer to your graphic.  Since we don't have another low-dimensional categorical variable in the dataset, we'll make one up to show how it `facet_grid` would work:

```{r}
d2 <- gapminder %>% 
   group_by(country) %>% 
   mutate(rand = sample(0:1, n(), replace = TRUE), 
          cool = ifelse(rand == 0, "not cool", "cool"))

ggplot(d2, 
   aes(gdpPercap, lifeExp)) +
   geom_point(aes(color = continent)) +
   geom_smooth() +
   scale_x_log10() +
   facet_grid(continent ~ cool, scales = "free_y")
```

And it doesn't have to be a scatterplot that gets faceted.  Check it out here where we use it on the density plot we created earlier.  

```{r}
ggplot(gapminder, aes(x = gdpPercap, fill = continent)) +
   geom_density(alpha = 0.4) +
  facet_wrap(~ continent, scales = "free") +
  theme(legend.position = "none")
```

## Time Dependent Graphs

Another very common type of multivariate plot is the visualization of time against other key variables, allowing us to see how key measures ebb and flow over the years, months, days, minutes and seconds.  Here we'll look at a few different ways of visualizing time, many of which are simply variations of other charts we've already seen. 

### Time Series

The simplest visualization of time is a line plot in which time is displayed on the X axis running from left to right (at least in Western cultures).  To do so, we call `geom_line` with x assigned to our time variable and y to whatever numeric variable we'd like to show.  Let's look at how life expectancy has changed over the years in the United States:

```{r}
gapminder %>% 
  filter(country == "United States") %>% 
  ggplot(aes(year, lifeExp)) +
  geom_line() 
```

Easy enough, but it is hard to read individual values in the graph above. When there are so few individual values, you may want to make some visual adjustments to make them easier to identify.  To do so, we'll add points to the chart with an additional layer that calls `geom_point`.  It will inherit the key aesthetics from the initial call, but we'll give it some fixed attributes on size and color.  And we'll make some similar adjustments within `geom_line`.  Finally we'll add some labeling to the plot and to the points.  For the latter, we add a `geom_text` layer, giving it a `label` aesthetic mapping, doing some rounding to the number and then setting the label to the right of the point with an `hjust`. 

```{r}
gapminder %>% 
  filter(country == "United States") %>% 
  ggplot(aes(year, lifeExp)) +
  geom_line(size = 1.5, 
            color = "lightgrey") +
  geom_point(size = 3, 
             color = "steelblue") +
  geom_text(aes(label = round(lifeExp, 1)), hjust = -0.3) +
  labs(y = "Life Expectancy (years)", 
       x = "Year",
       title = "Life expectancy changes over time",
       subtitle = "United States (1952-2007)",
       caption = "Source: http://www.gapminder.org/data/")
```

That was an instance of just a few data points.  Let's look at a plot with many.  The `economics` dataset comes with ggplot and it contains US monthly economic data collected from January 1967 thru January 2015. Let’s plot the personal savings rate (psavert) over time using our simple line plot.


```{r}
ggplot(economics, aes(date, psavert)) +
  geom_line() +
  labs(title = "Personal Savings Rate",
       x = "Date",
       y = "Personal Savings Rate")
```

The scale_x_date function can be used to reformat dates and change the tick marks.  Below we pass it parameters so that ticks appear every 5 years and dates are presented in MMM-YY format. (To see all the various options for data formatting, use `help(strptime)`).  We make a few other tweaks, giving the line some color and setting the size, adding a loess smoother, putting labels on the plot and simplifying the theme.  

```{r}
library(ggplot2)
library(scales)
ggplot(economics, aes(x = date, y = psavert)) +
  geom_line(color = "indianred3", 
            size=1 ) +
  geom_smooth() +
  scale_x_date(date_breaks = '5 years', 
               labels = label_date("%b-%y")) +
  labs(title = "Personal Savings Rate",
       subtitle = "1967 to 2015",
       x = "",
       y = "Personal Savings Rate") +
  theme_minimal()
```

This can just as easily be turned into an area chart, by changing to a `geom_area`.

```{r}
ggplot(economics, aes(date, psavert)) +
  geom_area(fill="lightblue", color="black") +
  labs(title = "Personal Savings Rate",
       x = "Date",
       y = "Personal Savings Rate")
```

Finally, there will be times when you'll need to display multiple time series on the same chart.  A good example of this is when you are comparing stock prices.  Let's compare closing prices for Apple and Netflix from 2013 through today. The `tq_get` function in the `tidyquant` package is used to obtain the stock data from Yahoo Finance.  (You'll have to install `tidyquant` first).  

The key thing here when displaying multiple time series is to 1) make sure the data is TALL and not WIDE, and 2) to map the color aesthetic to the categorical variable that differentiates between the multiple series, in this case `symbol`.  

You'll notice that I also added some modifications to the axes through `scale_x_date` and `scale_y_continuous`, as well as labeling, a minimal theme and setting the colors using a pre-built palette.  

```{r}
# install.packages("tidyquant")
library(tidyquant)

stocks <- tq_get(c("AAPL", "NFLX"), get = "stock.prices")

ggplot(stocks, aes(date, close, color=symbol)) + 
  geom_line(size=1) +
  scale_x_date(date_breaks = '1 year', 
               labels = label_date("%y")) +
  scale_y_continuous(labels = label_dollar()) +
  labs(title = "NASDAQ Closing Prices",
       subtitle = "2013 - 2023",
       caption = "source: Yahoo Finance",
       y = "Closing Price") +
  theme_minimal() +
  scale_color_brewer(palette = "Dark2")
```


### Dumbbell charts

Dumbbell charts are useful for displaying change between two (AND ONLY TWO!) time points for several groups or observations. You end up with a visualization that looks like a dumbbell with two points representing the values at two different times, connected by a line segment.  The `geom_dumbbell` function comes from the `ggalt` package.  

Using the gapminder dataset let’s plot the change in life expectancy from 1952 to 2007 in the Americas. Unlike the stock data above, to visualize the `geom_dumbbell` you need the data to be in a WIDE format, instead of the tall format it is currently in.  So we will need to convert it.  We do this using a function we have not covered but that is EXTREMELY useful: `pivot_wider`.  There is also a corresponding `pivot_longer`.  Here we are telling it to turn the data into a wider table and to use the `years` variable to make new columns with a specific prefix, and populate those new columns with the values from the `lifeExp` variable.

```{r}
# install.packages("ggalt")
library(ggalt)

gapminder %>% 
  filter(continent == "Americas" &
           year %in% c(1952, 2007)) %>%
  select(country, year, lifeExp) %>% 
  pivot_wider(names_from = year, 
              values_from = lifeExp, names_prefix = "year_") %>% 
  ggplot(aes(y = country, x = year_1952, xend = year_2007)) +  
  geom_dumbbell()
```

The graph will be easier to read if the countries are sorted and the points are sized and colored. In the next graph, we’ll sort by 2007 life expectancy, and modify the line and point size, color the points, add titles and labels, and simplify the theme.

```{r}
gapminder %>% 
  filter(continent == "Americas" &
           year %in% c(1952, 2007)) %>%
  select(country, year, lifeExp) %>% 
  pivot_wider(names_from = year, 
              values_from = lifeExp, names_prefix = "year_") %>% 
  ggplot(aes(y = reorder(country, year_2007), x = year_1952, xend = year_2007)) +  
  geom_dumbbell(size = 1.2,
                size_x = 3, 
                size_xend = 3,
                colour = "grey", # yes, you must use the british spelling for this one
                colour_x = "lightgreen", 
                colour_xend = "darkgreen") +
  theme_minimal() + 
  labs(title = "Change in Life Expectancy",
       subtitle = "1952 to 2007",
       x = "Life Expectancy (years)",
       y = "")
```

### Slope graphs

Slope graphs are an alternative to dumbbell charts and can be particularly useful when you have several time points, but not enough consistency for a typical line chart.  To demonstrate, we'll plot life expectancy for six Central American countries in 1992, 1997, 2002, and 2007 from the gapminder data.  There are ways to do this on your own using typical ggplot calls, but there is a useful function that makes things easier:  the `newggslopegraph` function from the `CGPfunctions` package.

In this case there is no distinct geom to add to a typical ggplot call, instead you simple call the function with four parameters: 

1) data frame
2) time variable (which must be a factor)
3) numeric variable to be plotted
4) grouping variable (creating one line per group).

It then has sensible defaults that it applies.  There are many changes you can make to things like line thickness - check the help page for details.

```{r}
# install.packages("CGPfunctions")
library(CGPfunctions)

gapminder %>%
  filter(year %in% c(1992, 1997, 2002, 2007) &
           country %in% c("Panama", "Costa Rica", 
                          "Nicaragua", "Honduras", 
                          "El Salvador", "Guatemala",
                          "Belize")) %>%
  mutate(year = factor(year),
         lifeExp = round(lifeExp)) %>% 
  newggslopegraph(year, lifeExp, country) +
  labs(title="Life Expectancy by Country", 
       subtitle="Central America", 
       caption="source: gapminder")
```

Now take a look at how this compares to what you have to do within ggplot natively in order to have something similar.  As you can see there is a lot more formatting work that you have to put in, but the tradeoff is that you have a LOT more control over how it looks.  We won't go into this in detail, but it is important to see that you can do this without an additional package.  Think of this as slicing an avocado with a kitchen knife, while the above is using a dedicated avocado slicer.  


```{r}
# one frustrating thing about the previous library is that it changes the default ggplot theme.   
# this next line of code fixes that.
theme_set(theme_grey()) 

# get the core data into an object
g2 <- gapminder %>%
  filter(year %in% c(1992, 1997, 2002, 2007) &
           country %in% c("Panama", "Costa Rica", 
                          "Nicaragua", "Honduras", 
                          "El Salvador", "Guatemala")) %>%
  mutate(lifeExp = round(lifeExp))

# in order to easily place the country labels on each side of the chart
# we create separate datasets that contain just the data for the year
# on the right and left.  I also need to make some minor adjustments to 
# that data so we don't have overlapping labels.
g_label_r <- g2 %>%
  filter(year == 2007) %>% 
  mutate(lifeExp = ifelse(country == "Honduras", lifeExp - 1, lifeExp)) # we are positioning the label based on lifExp, but Honduras overlaps with another

g_label_l <- g2 %>%
  filter(year == 1992) %>% 
  mutate(lifeExp = ifelse(country == "Nicaragua", lifeExp - 1, lifeExp)) # we are positioning the label based on lifExp, but Nicaragua overlaps with another

ggplot(g2, aes(year, lifeExp, color = country)) +
  geom_line(linewidth = 3) + # it inherits the x, y and color aesthetics
  geom_label(aes(label = lifeExp), fill = "white", label.size = 0) + # put the actual lifExp on the chart
  geom_text(data = g_label_r, aes(label = country, x = year + 0.5), hjust = 0) + # Add country labels, moving them over slightly, and then justifying appropriately
  geom_text(data = g_label_l, aes(label = country, x = year - 0.5), hjust = 1) + # Add country labels, moving them over slightly, and then justifying appropriately
  labs(title="Life Expectancy by Country", 
       subtitle="Central America", 
       caption="source: gapminder",
       x = "Year", y = "") +
  scale_x_continuous(limits = c(1989, 2010),  # forcing the scale wider so that we have room for the labels
                     breaks = c(1992, 1997, 2002, 2007)) + # forcing the major gridline breaks so it looks good.
  scale_y_continuous(limits = c(62, NA)) + # forcing a slightly lower limit so we don't have text cut off
  theme_minimal() +
  theme(legend.position = "none",
        panel.grid.major.y = element_blank(), # removing major grid lines on the Y
        panel.grid.minor = element_blank(), # removing minor grid lines on all axes
        axis.line.y = element_blank(), # no lines on y
        axis.ticks.y = element_blank(), # no ticks on y
        axis.text.y = element_blank()) # no text on y
```

### Area charts

A stacked area chart can be used to show differences between groups over time, especially when they are raw numbers.  Like a pie chart, you'll want to be sure you only have a handful of variables - as you add categories, comprehension becomes more and more difficult.  Let's take a look at how the population of each continent has grown over time:

```{r}
gapminder %>% 
  group_by(continent, year) %>% 
  summarize(total_pop = sum(pop)) %>% 
  ggplot(aes(year, total_pop, fill = continent)) +
  geom_area() +
  labs(title = "World Population by Continent",
       x = "Year",
       y = "Population")
```

There are a few ways to clean this up, most notably getting rid of that ugly scientific notation.  Remember that we are typically communicating with non-experts, and they will not be well versed in how to read scientific notation - heck, I'm not very good at reading it!  We can fix that with a simple use of a `scales` function.  Here are all the improvements we can make:

- order the continents from the largest pop to the smallest
- improve labeling
- choose a different color scheme

```{r}
# stacked area chart
gapminder %>% 
  group_by(continent, year) %>% 
  summarize(total_pop = sum(pop)) %>% 
  ggplot(aes(year, total_pop, fill = reorder(continent, total_pop))) +
  geom_area() +
  labs(title = "World Population by Continent",
       x = "Year",
       y = "Population (billions)",
       fill = "Continent")+
  scale_fill_brewer(palette = "Set2") +
  scale_y_continuous(labels = label_number(scale = 1/1e9, suffix = "b"))
```

Apparently, the number of young children have not changed very much in the past 100 years.

Stacked area charts are most useful when interest is on both (1) group change over time and (2) overall change over time. Place the most important groups at the bottom. These are the easiest to interpret in this type of plot.

```{r}
# 100% stacked area chart
gapminder %>% 
  group_by(year) %>% 
  mutate(global_pop = sum(pop)) %>% 
  group_by(continent, year) %>% 
  summarize(total_pop = sum(pop),
            total_pop_pct = total_pop / global_pop) %>% 
  ggplot(aes(year, total_pop_pct, fill = reorder(continent, total_pop))) +
  geom_area(color = "white") +
  scale_y_continuous(labels = label_percent()) +
  labs(title = "% of World Population by Continent",
       x = "Year",
       y = "% of World Population", 
       fill = "Continent")
```

